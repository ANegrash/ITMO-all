В своей статье Эдвард Ли (Edward Lee) высказывает не самое популярное мнение о том, что многопоточность в программировании - чаще плохое явление, чем хорошее.
В качестве аргументов приводится целый ряд проблем, с которыми сталкиваются при разработке многопоточных программ. Первая из них – одновременный доступ и синхронное изменение одних и тех же данных из разных потоков. Этот пример известен даже не самым продвинутым программистам, и, казалось бы, в языках программирования придумали специальные конструкции (например, synchronized в Java), которые позволяют заблокировать доступ к данным при их использовании. Однако это может приводить к deadlock-ам, которые с высокой вероятностью уронят программу. Ещё одним важным аспектом против многопоточности выступает верное математическое вычисление, которое провёл и описал в статье сам Эдвард Ли. В этом вычислении мы видим, что разделённая на несколько потоков программа имеет не слишком большой выигрыш во времени выполнения относительно программ, написанных в одном потоке и выполняемых последовательно. Таким образом автор призывает к идее, что использование потоков разрушает такие неотъемлемые свойства последовательных вычислений как: понятность, предсказуемость и определенность (детерминированность). И любая многопоточная программа не может быть предсказуема на 100%, что не только может создать проблемы при её использовании, но и затрудняет разработку, так как программист, по сути, должен «стать безумным».
Эта статья вышла в далёком 2006 году, что обычно свидетельствует о безнадёжно устаревшем материале. Однако здесь мы видим достаточно необычный случай, когда информация, содержащаяся в статье, актуальна во многом и по сей день, спустя 16 лет. Такое «нестарение» делает эту статью достаточно уникальной как с научной, так и с практической точки зрения.
Моё скромное мнение относительно темы, описанной в материале статьи, следующее: я согласен, что многопоточность может создать некоторые проблемы, предсказать которые программисты зачастую даже не в силах. Также я не берусь судить о крупных научных системах, где используется немного другой вариант распараллеливания потоков, который был описан в статье, так как я не обладаю достаточной компетенцией и знаниями для утверждения хоть сколько-нибудь справедливых выводов. Однако я также считаю, что распараллеливание программ даже на том уровне, который доступен нам сейчас, может и должен существенно помочь программистам. Для хорошей работы с многопоточностью необходимо грамотно использовать распределение данных по системе и понимать, за что отвечает каждый из потоков, не плодя лишних потоков, которые, наоборот, лишь ухудшат производительность.
Статья оказалась достаточно интересным материалом, заставившим меня несколько дней думать о высказанных в ней постулатах, так что, вероятно, я даже вернусь к ней позже для повторного, более детального анализа.